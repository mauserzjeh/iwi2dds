package main

import (
	"encoding/binary"
	"errors"
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/mauserzjeh/iwi"
)

type (
	DDSHeader struct {
		dwMagic             uint32
		dwSize              uint32
		dwFlags             uint32
		dwHeight            uint32
		dwWidth             uint32
		dwPitchOrLinearSize uint32
		dwDepth             uint32
		dwMipMapCount       uint32
		dwReserved1         [11]uint32
		pixelFormat         DDSPixelFormat
		caps                DDSCaps
		dwReserved2         uint32
	}

	DDSPixelFormat struct {
		dwSize        uint32
		dwFlags       uint32
		dwFourCC      uint32
		dwRGBBitCount uint32
		dwRBitMask    uint32
		dwGBitMask    uint32
		dwBBitMask    uint32
		dwABitMask    uint32
	}

	DDSCaps struct {
		dwCaps1    uint32
		dwCaps2    uint32
		dwDDSX     uint32
		dwReserved uint32
	}
)

const (
	// DDS Flags
	DDSD_CAPS        = 0x1
	DDSD_HEIGHT      = 0x2
	DDSD_WIDTH       = 0x4
	DDSD_PITCH       = 0x8
	DDSD_PIXELFORMAT = 0x1000
	DDSD_MIPMAPCOUNT = 0x20000
	DDSD_LINEARSIZE  = 0x80000
	DDSD_DEPTH       = 0x800000

	// DDS Pixel Format Flags
	DDPF_ALPHAPIXELS = 0x1
	DDPF_ALPHA       = 0x2
	DDPF_FOURCC      = 0x4
	DDPF_RGB         = 0x40
	DDPF_YUV         = 0x200
	DDPF_LUMINANCE   = 0x20000

	// DDS Caps Flags
	DDSCAPS_COMPLEX = 0x8
	DDSCAPS_MIPMAP  = 0x400000
	DDSCAPS_TEXTURE = 0x1000

	// DXTN Formats
	DXT1 = ('D' << 0) | ('X' << 8) | ('T' << 16) | ('1' << 24)
	DXT3 = ('D' << 0) | ('X' << 8) | ('T' << 16) | ('3' << 24)
	DXT5 = ('D' << 0) | ('X' << 8) | ('T' << 16) | ('5' << 24)
)

var (
	input  = flag.String("i", "", "The input .iwi file to convert")
	output = flag.String("o", "", "The output .dds file. If not set, then will be autogenerated based on the input file")
)

func main() {
	flag.Parse()

	if *input == "" {
		fmt.Fprintln(os.Stderr, errors.New("no input file given"))
		os.Exit(1)
	}

	if *output == "" {
		*output = strings.TrimSuffix(*input, ".iwi") + ".dds"
	}

	i, err := iwi.ReadIWI(*input)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}

	err = writeDDS(i, *output)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
}

// writeDDS
func writeDDS(i *iwi.IWI, output string) error {
	var ddsPixelFormat DDSPixelFormat

	switch i.Info.Format {
	case iwi.IWI_FORMAT_ARGB32:

		ddsPixelFormat.dwSize = 32
		ddsPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS
		ddsPixelFormat.dwFourCC = 0x0
		ddsPixelFormat.dwRGBBitCount = 32
		ddsPixelFormat.dwRBitMask = 0x00ff0000
		ddsPixelFormat.dwGBitMask = 0x0000ff00
		ddsPixelFormat.dwBBitMask = 0x000000ff
		ddsPixelFormat.dwABitMask = 0xff000000

	case iwi.IWI_FORMAT_RGB24:

		ddsPixelFormat.dwSize = 32
		ddsPixelFormat.dwFlags = DDPF_RGB
		ddsPixelFormat.dwFourCC = 0x0
		ddsPixelFormat.dwRGBBitCount = 24
		ddsPixelFormat.dwRBitMask = 0xff0000
		ddsPixelFormat.dwGBitMask = 0x00ff00
		ddsPixelFormat.dwBBitMask = 0x0000ff
		ddsPixelFormat.dwABitMask = 0x0

	case iwi.IWI_FORMAT_GA16:

		ddsPixelFormat.dwSize = 32
		ddsPixelFormat.dwFlags = DDPF_RGB
		ddsPixelFormat.dwFourCC = 0x0
		ddsPixelFormat.dwRGBBitCount = 16
		ddsPixelFormat.dwRBitMask = 0b00001111_00000000
		ddsPixelFormat.dwGBitMask = 0b00000000_11110000
		ddsPixelFormat.dwBBitMask = 0b00000000_00001111
		ddsPixelFormat.dwABitMask = 0b11110000_00000000

	case iwi.IWI_FORMAT_A8:

		ddsPixelFormat.dwSize = 32
		ddsPixelFormat.dwFlags = DDPF_ALPHA
		ddsPixelFormat.dwFourCC = 0x0
		ddsPixelFormat.dwRGBBitCount = 8
		ddsPixelFormat.dwRBitMask = 0x0
		ddsPixelFormat.dwGBitMask = 0x0
		ddsPixelFormat.dwBBitMask = 0x0
		ddsPixelFormat.dwABitMask = 0xff

	case iwi.IWI_FORMAT_DXT1:

		ddsPixelFormat.dwSize = 32
		ddsPixelFormat.dwFlags = DDPF_FOURCC
		ddsPixelFormat.dwFourCC = DXT1
		ddsPixelFormat.dwRGBBitCount = 0
		ddsPixelFormat.dwRBitMask = 0
		ddsPixelFormat.dwGBitMask = 0
		ddsPixelFormat.dwBBitMask = 0
		ddsPixelFormat.dwABitMask = 0

	case iwi.IWI_FORMAT_DXT3:

		ddsPixelFormat.dwSize = 32
		ddsPixelFormat.dwFlags = DDPF_FOURCC
		ddsPixelFormat.dwFourCC = DXT3
		ddsPixelFormat.dwRGBBitCount = 0
		ddsPixelFormat.dwRBitMask = 0
		ddsPixelFormat.dwGBitMask = 0
		ddsPixelFormat.dwBBitMask = 0
		ddsPixelFormat.dwABitMask = 0

	case iwi.IWI_FORMAT_DXT5:

		ddsPixelFormat.dwSize = 32
		ddsPixelFormat.dwFlags = DDPF_FOURCC
		ddsPixelFormat.dwFourCC = DXT5
		ddsPixelFormat.dwRGBBitCount = 0
		ddsPixelFormat.dwRBitMask = 0
		ddsPixelFormat.dwGBitMask = 0
		ddsPixelFormat.dwBBitMask = 0
		ddsPixelFormat.dwABitMask = 0

	default:
		return fmt.Errorf("invalid format: %v", i.Info.Format)
	}

	ddsCaps := DDSCaps{
		dwCaps1:    DDSCAPS_TEXTURE,
		dwCaps2:    0,
		dwDDSX:     0,
		dwReserved: 0,
	}

	ddsHeader := DDSHeader{
		dwMagic:             ('D' << 0) | ('D' << 8) | ('S' << 16) | (' ' << 24),
		dwSize:              124,
		dwFlags:             DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_LINEARSIZE,
		dwHeight:            uint32(i.Info.Height),
		dwWidth:             uint32(i.Info.Width),
		dwPitchOrLinearSize: uint32(len(i.Data)),
		dwDepth:             0,
		dwMipMapCount:       0,
		dwReserved1:         [11]uint32{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
		pixelFormat:         ddsPixelFormat,
		caps:                ddsCaps,
		dwReserved2:         0,
	}

	f, err := os.Create(output)
	if err != nil {
		return err
	}
	defer f.Close()

	err = binary.Write(f, binary.LittleEndian, ddsHeader)
	if err != nil {
		return err
	}

	err = binary.Write(f, binary.LittleEndian, i.Data)
	if err != nil {
		return err
	}

	return nil
}
